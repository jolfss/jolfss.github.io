/**
 * .rem-height-ceil-js
 *
 * This script runs immediately on load, on DOM ready, after MathJax renders, when images load,
 * and when the window resizes. It finds all elements with the class 'rem-height-ceil-js',
 * calculates their actual content height, and adjusts the container's height to be the nearest
 * multiple of 2rem.
 *
 * Requires:
 * - The container does not contain any elements that are themselves rem-height-ceil-js.
 *   (Or really *any* other dynamically resizing elements.)
 *
 * NOTE: This script was originally generated by Google Gemini and has been modified.
 */

// Cache the rem value to avoid repeated calculations
let remInPixels = null;
let resizeTimer;

// Calculate and cache the rem value
const getRemInPixels = () => {
    if (remInPixels === null) {
        remInPixels = parseFloat(getComputedStyle(document.documentElement).fontSize);
        if (isNaN(remInPixels) || remInPixels <= 0) {
            console.error("Could not determine the pixel value of 1rem. Aborting script.");
            return null;
        }
    }
    return remInPixels;
};

// Resize a specific container
const resizeContainer = (container) => {
    try {
        const rem = getRemInPixels();
        if (rem === null) return;

        // Temporarily reset height to auto to measure the natural content height accurately.
        container.style.height = 'auto';

        // Get the total height of the content within the box.
        const contentHeight = container.scrollHeight;

        // Calculate the new height ceiled to the nearest multiple of (2 * 1rem).
        const stepHeight = 2 * rem;
        const newHeightInPixels = Math.ceil(contentHeight / stepHeight) * stepHeight;

        // Apply the new height to the container.
        container.style.height = `${newHeightInPixels}px`;

    } catch (error) {
        console.error("An error occurred while resizing container:", error);
    }
};

// Resize all containers
const resizeContainers = () => {
    try {
        // Select all the containers that need their height adjusted.
        const containers = document.querySelectorAll('.rem-height-ceil-js');

        if (containers.length === 0) {
            console.log("Resizable container script ran, but no elements with the class '.rem-height-ceil-js' were found.");
            return;
        }

        // Iterate over each container and adjust its height.
        containers.forEach(resizeContainer);

    } catch (error) {
        console.error("An error occurred during the rem resize container script:", error);
    }
};

const scheduleResize = (delay = 50) => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(resizeContainers, delay);
};

// Set up image load listeners for a container
const attachImageLoadListeners = (container) => {
    const images = container.querySelectorAll('img');
    images.forEach(img => {
        // Only attach listener if image hasn't loaded yet
        if (!img.complete) {
            img.addEventListener('load', () => {
                resizeContainer(container);
            }, { once: true });

            // Also handle error case to prevent hanging
            img.addEventListener('error', () => {
                resizeContainer(container);
            }, { once: true });
        }
    });
};

// Initialize all containers
const initializeContainers = () => {
    const containers = document.querySelectorAll('.rem-height-ceil-js');
    containers.forEach(container => {
        resizeContainer(container);
        attachImageLoadListeners(container);
    });
};

// Set up MutationObserver to detect dynamic content changes
const observeContentChanges = () => {
    const containers = document.querySelectorAll('.rem-height-ceil-js');

    const observer = new MutationObserver(() => {
        // Debounce the resize to avoid excessive recalculations
        scheduleResize();
    });

    containers.forEach(container => {
        observer.observe(container, {
            childList: true,
            subtree: true,
            characterData: true
        });
    });
};

// Hook into MathJax typesetting completion
const setupMathJaxHook = () => {
    if (typeof MathJax !== 'undefined' && MathJax.startup && MathJax.startup.promise) {
        MathJax.startup.promise.then(() => {
            // MathJax has completed initial typesetting
            resizeContainers();
        }).catch((err) => {
            console.error("MathJax initialization error:", err);
        });
    }
};

// Ensure height adjustments run after web fonts finish loading so that
// shifted glyph metrics don't knock panels off the grid.
const setupFontLoadHooks = () => {
    if (!document.fonts) {
        return;
    }

    const handleFontEvent = () => scheduleResize(0);

    document.fonts.ready
        .then(handleFontEvent)
        .catch((err) => {
            console.error("Font loading error:", err);
        });

    if (typeof document.fonts.addEventListener === 'function') {
        document.fonts.addEventListener('loadingdone', handleFontEvent);
        document.fonts.addEventListener('loadingerror', handleFontEvent);
    }
};

// --- Event Listeners ---

// 1. Run immediately on script load (before DOMContentLoaded)
//    This provides an initial sizing even before all content is parsed
if (document.readyState === 'loading') {
    // Still parsing, run as soon as possible
    resizeContainers();
} else {
    // DOM already ready or interactive
    initializeContainers();
}

// 2. Run the script once the DOM is ready (doesn't wait for images).
document.addEventListener('DOMContentLoaded', () => {
    initializeContainers();
    observeContentChanges();
    setupMathJaxHook();
});

// 3. Rerun the script when the window is resized (with debouncing).
window.addEventListener('resize', () => {
    scheduleResize();
});

// 4. Kick off font hooks immediately as well in case DOMContentLoaded has
//    already fired (e.g., script injected at the end of the document).
setupFontLoadHooks();
